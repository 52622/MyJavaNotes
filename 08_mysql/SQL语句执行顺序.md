书写顺序
```sql
必选
select from 
可选
where group by having order by
```

执行顺序

```SQL
from:需要从哪个数据表检索数据 
where:过滤表中数据的条件 
group by:如何将上面过滤出的数据分组 
having:对上面已经分组的数据进行过滤的条件  
select:查看结果集中的哪个列，或列的计算结果 
order by :按照什么样的顺序来查看返回的数据 
```

```SQL
from后面的表关联，是自右向左解析的 
而where条件的解析顺序是自下而上的
尽量把数据量大的表放在最右边来进行关联
能筛选出大量数据的条件放在where语句的最下面
```



```SQL

SQL Select语句完整的执行顺序【从DBMS使用者角度】： 
　　1、from子句组装来自不同数据源的数据； 
　　2、where子句基于指定的条件对记录行进行筛选； 
　　3、group by子句将数据划分为多个分组； 
　　4、使用聚集函数进行计算； 
　　5、使用having子句筛选分组； 
　　6、计算所有的表达式； 
　　7、使用order by对结果集进行排序。 

SQL Select语句的执行步骤【从DBMS实现者角度，这个对我们用户意义不大】： 
　　1）语法分析，分析语句的语法是否符合规范，衡量语句中各表达式的意义。 
　　2）语义分析，检查语句中涉及的所有数据库对象是否存在，且用户有相应的权限。 
　　3）视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。 
　　4）表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。 
　　5）选择优化器，不同的优化器一般产生不同的“执行计划” 
　　6）选择连接方式， ORACLE 有三种连接方式，对多表连接 ORACLE 可选择适当的连接方式。 
　　7）选择连接顺序， 对多表连接 ORACLE 选择哪一对表先连接，选择这两表中哪个表做为源数据表。 
　　8）选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式。 
　　9）运行“执行计划”。 
　　
```



查询语句

```shell
1. tcp连接，连接器，连接器会对该请求进行权限验证及连接资源分配
2. 发送语句，命令分发器
	是一条select语句？ 是 开启查询缓存？ 是 查询缓存中查找该SQL是否完全匹配？ 是 验证当前用户是否具备查询权限？ 是
	以上都通过，直接返回结果集给客户端
	(MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息)
3. 缓存未命中，分析器
	如果语法不对，就会返回语法错误中断查询
4. 预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义等
5. 优化器进行优化（通过索引选择最快的查找方式），并生成执行计划
6. 执行器执行语句
	该用户是否具有查询权限？ 是 执行器开始执行，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端
（缓存到查询缓存受到几个参数的影响 1.query_cache_type 是否打开查询缓存,默认为OFF  2.query_cache_size:查询缓存使用的总内存空间,默认值为1M   3.query_cache_limit 对于大于该值的结果集不会被缓存，默认值1M，在8.0版本后该参数被移除了）（如果该SQL执行过程中超过了慢查询阀值，该SQL会被记录到慢查询日志中）

```



更新语句

```shell
1. TCP连接，连接器，连接器会对该请求进行权限验证及连接资源分配
2. 客户端发送一条语句，mysql收到该语句后，通过命令分发器判断其是否是一条更新语句，如果是，则直接发送给分析器做语法分析
3. 分析器阶段，MySQL需要知道到底要查哪些东西，如果语法不对，就会返回语法错误中断查询
4.分析器的工作完成后，将语句传递给预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义等

 5.语句解析完成后，MySQL就知道要查什么了，之后会将语句传递给优化器进行优化（通过索引选择最快的查找方式），并生成执行计划。

 6.执行器根据生成的执行计划去open table，此时会先去查看该表上是否有元数据（MDL）排他锁（如果有元数据共享锁则无影响），如果有元数据排他锁，则事物被阻塞，进入等待状态（时间由lock_wait_timeout决定，默认是一年。。。。），等元数据锁被释放，继续执行。如果无元数据锁或者是有元数据共享锁，则该事务在表上加元数据共享锁（因为元数据共享读锁之间是不冲突的，如果表上有元数据共享锁，我们执行alter table这样的DDL语句时，会进入等待状态，因为DDL语句需要在表上加元数据排他锁）

 7.进入引擎层（默认innodb），去innodb_buffer_pool里面的data dictionary得到表得相关信息

 8.根据表信息去innodb_buffer_pool里面的lock info查看是否有相关的锁信息，如果有则等待（因为要加排它锁），如果没有则加排它锁，更新lock info。

 9.取读取相关数据页到innodb_buffer_pool中（如果数据页本身就在缓存中，则不用从硬盘读取）

10.将页中的原始数据（快照）保存到undo log buffer中（undo log buffer会以相关参数定义的规则进行刷盘操作写入到undo tablespace中）

11.在innodb_buffer_pool中将相关页面更新，该页变成脏页（脏页会以相关参数定义的规则进行刷盘操作写入所属表空间中）

12.页面修改完成后，会把修改后的物理页面保存到redo log buffer中，（redo log buffer会以相关参数定义的规则进行刷盘操作写入到redo tablespace中）

13.如果开启binlog，则更新数据的逻辑语句也会记录在binlog_cache中（binlog会以相关参数定义的规则进行刷盘操作写入到binlog file 中）

14.如果该表上有二级索引并且本次操作会影响到二级索引，则会把相关的二级索引修改写入到innodb_buffer_pool中的change buffer里（change buffer 会以相关参数定义的规则进行刷盘操作写入所属表空间中）

15.前期的准备工作到此已经做完了，之后便是事务的commit或者rollback操作。一般情况下执行的是commit操作

16.执行commit操作后（mysql默认开启自动提交，如果手动开始事务begin，则需要显示提交commit），由于要保证redolog与binlog的一致性，redolog采用2阶段提交方式。

17.将undo log buffer及redo log buffer刷盘（innodb_flush_log_at_trx_commit=1），并将该事务的redolog标记为prepare状态。

18.将binlog_cache数据刷盘（sync_binlog=1）

19.如果开启了主从结构，此时会将binlog_cache中的信息通过io线程发送给从机，如果开启了半同步复制则需要等待从机落盘（relay log）并反馈。如果是异步复制则无需等待(默认是异步复制)

20.待binlog落盘完成，再将redolog中该事务信息标记为commit，释放相关锁资源。此时一个更新事务的操作已经完成，返回给客户端成功更新提示。

21.标记undolog中该事务修改页的原始快照信息为delete，当无其他事务引用该原始数据时(MVCC)，再将其删除

22.如果此时触发了脏页刷盘操作，会先将脏页写入到double write buffer中（防止写入过程中出现断页，因为mysql页面默认为16K，linux操作系统最大为4K，如果写了8K时系统挂了，这个数据页将不完整，标记为损坏）然后再写到期所在表空间的相应位置。
```





https://blog.csdn.net/waterxcfg304/article/details/19082135 ORACLE数据库SQL优化--->基于成本的优化器

https://www.cnblogs.com/hellohell/p/5718238.html MySQL采用了基于开销的优化器 

https://blog.csdn.net/unixboy_xujf/article/details/83219329 针对Oracle数据库的优化器详细介绍

https://www.cnblogs.com/huminxxl/p/3149097.html SQL语句执行顺序

https://blog.csdn.net/finalkof1983/article/details/84450896 MySQL中一条SQL语句的执行过程

https://blog.csdn.net/heng_yan/article/details/78324176 mysql的sql执行计划详解